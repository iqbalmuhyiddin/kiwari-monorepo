// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: acct_reports.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getCashBalances = `-- name: GetCashBalances :many
SELECT
    ca.id AS cash_account_id,
    ca.cash_account_code,
    ca.cash_account_name,
    COALESCE(SUM(CASE WHEN ct.line_type IN ('SALES', 'CAPITAL') THEN ct.amount END), 0)::text AS total_in,
    COALESCE(SUM(CASE WHEN ct.line_type IN ('INVENTORY', 'EXPENSE', 'COGS', 'DRAWING') THEN ct.amount END), 0)::text AS total_out
FROM acct_cash_transactions ct
JOIN acct_cash_accounts ca ON ca.id = ct.cash_account_id
WHERE ct.cash_account_id IS NOT NULL
GROUP BY 1, 2, 3
ORDER BY 2
`

type GetCashBalancesRow struct {
	CashAccountID   uuid.UUID `json:"cash_account_id"`
	CashAccountCode string    `json:"cash_account_code"`
	CashAccountName string    `json:"cash_account_name"`
	TotalIn         string    `json:"total_in"`
	TotalOut        string    `json:"total_out"`
}

// All-time net cash position per cash account (for dashboard cards).
func (q *Queries) GetCashBalances(ctx context.Context) ([]GetCashBalancesRow, error) {
	rows, err := q.db.Query(ctx, getCashBalances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCashBalancesRow{}
	for rows.Next() {
		var i GetCashBalancesRow
		if err := rows.Scan(
			&i.CashAccountID,
			&i.CashAccountCode,
			&i.CashAccountName,
			&i.TotalIn,
			&i.TotalOut,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCashFlowReport = `-- name: GetCashFlowReport :many
SELECT
    date_trunc('month', ct.transaction_date)::date AS period,
    ca.id AS cash_account_id,
    ca.cash_account_code,
    ca.cash_account_name,
    COALESCE(SUM(CASE WHEN ct.line_type IN ('SALES', 'CAPITAL') THEN ct.amount END), 0)::text AS cash_in,
    COALESCE(SUM(CASE WHEN ct.line_type IN ('INVENTORY', 'EXPENSE', 'COGS', 'DRAWING') THEN ct.amount END), 0)::text AS cash_out
FROM acct_cash_transactions ct
JOIN acct_cash_accounts ca ON ca.id = ct.cash_account_id
WHERE
    ct.cash_account_id IS NOT NULL AND
    ($1::date IS NULL OR ct.transaction_date >= $1) AND
    ($2::date IS NULL OR ct.transaction_date <= $2) AND
    ($3::uuid IS NULL OR ct.outlet_id = $3)
GROUP BY 1, 2, 3, 4
ORDER BY 1, 3
`

type GetCashFlowReportParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	OutletID  pgtype.UUID `json:"outlet_id"`
}

type GetCashFlowReportRow struct {
	Period          pgtype.Date `json:"period"`
	CashAccountID   uuid.UUID   `json:"cash_account_id"`
	CashAccountCode string      `json:"cash_account_code"`
	CashAccountName string      `json:"cash_account_name"`
	CashIn          string      `json:"cash_in"`
	CashOut         string      `json:"cash_out"`
}

// Returns cash in/out per month per cash account for Cash Flow statement.
// Cash In = SALES + CAPITAL; Cash Out = INVENTORY + EXPENSE + COGS + DRAWING.
func (q *Queries) GetCashFlowReport(ctx context.Context, arg GetCashFlowReportParams) ([]GetCashFlowReportRow, error) {
	rows, err := q.db.Query(ctx, getCashFlowReport, arg.StartDate, arg.EndDate, arg.OutletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCashFlowReportRow{}
	for rows.Next() {
		var i GetCashFlowReportRow
		if err := rows.Scan(
			&i.Period,
			&i.CashAccountID,
			&i.CashAccountCode,
			&i.CashAccountName,
			&i.CashIn,
			&i.CashOut,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyPnlSummary = `-- name: GetMonthlyPnlSummary :one
SELECT
    COALESCE(SUM(CASE WHEN line_type = 'SALES' THEN amount END), 0)::text AS net_sales,
    COALESCE(SUM(CASE WHEN line_type = 'COGS' THEN amount END), 0)::text AS cogs,
    COALESCE(SUM(CASE WHEN line_type = 'EXPENSE' THEN amount END), 0)::text AS expenses
FROM acct_cash_transactions
WHERE transaction_date >= $1 AND transaction_date < $2
`

type GetMonthlyPnlSummaryParams struct {
	MonthStart pgtype.Date `json:"month_start"`
	MonthEnd   pgtype.Date `json:"month_end"`
}

type GetMonthlyPnlSummaryRow struct {
	NetSales string `json:"net_sales"`
	Cogs     string `json:"cogs"`
	Expenses string `json:"expenses"`
}

// Current month P&L totals (for dashboard mini-summary).
func (q *Queries) GetMonthlyPnlSummary(ctx context.Context, arg GetMonthlyPnlSummaryParams) (GetMonthlyPnlSummaryRow, error) {
	row := q.db.QueryRow(ctx, getMonthlyPnlSummary, arg.MonthStart, arg.MonthEnd)
	var i GetMonthlyPnlSummaryRow
	err := row.Scan(&i.NetSales, &i.Cogs, &i.Expenses)
	return i, err
}

const getPendingReimbursementsSummary = `-- name: GetPendingReimbursementsSummary :one
SELECT
    COUNT(*) AS total_count,
    COALESCE(SUM(amount), 0)::text AS total_amount
FROM acct_reimbursement_requests
WHERE status IN ('Draft', 'Ready')
`

type GetPendingReimbursementsSummaryRow struct {
	TotalCount  int64  `json:"total_count"`
	TotalAmount string `json:"total_amount"`
}

// Count + total of Draft + Ready reimbursements (for dashboard badge).
func (q *Queries) GetPendingReimbursementsSummary(ctx context.Context) (GetPendingReimbursementsSummaryRow, error) {
	row := q.db.QueryRow(ctx, getPendingReimbursementsSummary)
	var i GetPendingReimbursementsSummaryRow
	err := row.Scan(&i.TotalCount, &i.TotalAmount)
	return i, err
}

const getProfitAndLossReport = `-- name: GetProfitAndLossReport :many
SELECT
    date_trunc('month', ct.transaction_date)::date AS period,
    ct.line_type,
    ct.account_id,
    a.account_code,
    a.account_name,
    SUM(ct.amount)::text AS total_amount
FROM acct_cash_transactions ct
JOIN acct_accounts a ON a.id = ct.account_id
WHERE
    ct.line_type IN ('SALES', 'COGS', 'EXPENSE') AND
    ($1::date IS NULL OR ct.transaction_date >= $1) AND
    ($2::date IS NULL OR ct.transaction_date <= $2) AND
    ($3::uuid IS NULL OR ct.outlet_id = $3)
GROUP BY 1, 2, 3, 4, 5
ORDER BY 1, 2, 4
`

type GetProfitAndLossReportParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	OutletID  pgtype.UUID `json:"outlet_id"`
}

type GetProfitAndLossReportRow struct {
	Period      pgtype.Date `json:"period"`
	LineType    string      `json:"line_type"`
	AccountID   uuid.UUID   `json:"account_id"`
	AccountCode string      `json:"account_code"`
	AccountName string      `json:"account_name"`
	TotalAmount string      `json:"total_amount"`
}

// Returns rows grouped by month, line type, and account for P&L computation.
// Handler groups by period, sums SALES/COGS/EXPENSE, computes gross profit/margins.
func (q *Queries) GetProfitAndLossReport(ctx context.Context, arg GetProfitAndLossReportParams) ([]GetProfitAndLossReportRow, error) {
	rows, err := q.db.Query(ctx, getProfitAndLossReport, arg.StartDate, arg.EndDate, arg.OutletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProfitAndLossReportRow{}
	for rows.Next() {
		var i GetProfitAndLossReportRow
		if err := rows.Scan(
			&i.Period,
			&i.LineType,
			&i.AccountID,
			&i.AccountCode,
			&i.AccountName,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
