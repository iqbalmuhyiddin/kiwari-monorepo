// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: acct_items.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAcctItem = `-- name: CreateAcctItem :one
INSERT INTO acct_items (item_code, item_name, item_category, unit, is_inventory, average_price, last_price, for_hpp, keywords)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, item_code, item_name, item_category, unit, is_inventory, is_active, average_price, last_price, for_hpp, keywords, created_at
`

type CreateAcctItemParams struct {
	ItemCode     string         `json:"item_code"`
	ItemName     string         `json:"item_name"`
	ItemCategory string         `json:"item_category"`
	Unit         string         `json:"unit"`
	IsInventory  bool           `json:"is_inventory"`
	AveragePrice pgtype.Numeric `json:"average_price"`
	LastPrice    pgtype.Numeric `json:"last_price"`
	ForHpp       pgtype.Numeric `json:"for_hpp"`
	Keywords     string         `json:"keywords"`
}

func (q *Queries) CreateAcctItem(ctx context.Context, arg CreateAcctItemParams) (AcctItem, error) {
	row := q.db.QueryRow(ctx, createAcctItem,
		arg.ItemCode,
		arg.ItemName,
		arg.ItemCategory,
		arg.Unit,
		arg.IsInventory,
		arg.AveragePrice,
		arg.LastPrice,
		arg.ForHpp,
		arg.Keywords,
	)
	var i AcctItem
	err := row.Scan(
		&i.ID,
		&i.ItemCode,
		&i.ItemName,
		&i.ItemCategory,
		&i.Unit,
		&i.IsInventory,
		&i.IsActive,
		&i.AveragePrice,
		&i.LastPrice,
		&i.ForHpp,
		&i.Keywords,
		&i.CreatedAt,
	)
	return i, err
}

const getAcctItem = `-- name: GetAcctItem :one
SELECT id, item_code, item_name, item_category, unit, is_inventory, is_active, average_price, last_price, for_hpp, keywords, created_at FROM acct_items WHERE id = $1 AND is_active = true
`

func (q *Queries) GetAcctItem(ctx context.Context, id uuid.UUID) (AcctItem, error) {
	row := q.db.QueryRow(ctx, getAcctItem, id)
	var i AcctItem
	err := row.Scan(
		&i.ID,
		&i.ItemCode,
		&i.ItemName,
		&i.ItemCategory,
		&i.Unit,
		&i.IsInventory,
		&i.IsActive,
		&i.AveragePrice,
		&i.LastPrice,
		&i.ForHpp,
		&i.Keywords,
		&i.CreatedAt,
	)
	return i, err
}

const listAcctItems = `-- name: ListAcctItems :many
SELECT id, item_code, item_name, item_category, unit, is_inventory, is_active, average_price, last_price, for_hpp, keywords, created_at FROM acct_items WHERE is_active = true ORDER BY item_code
`

func (q *Queries) ListAcctItems(ctx context.Context) ([]AcctItem, error) {
	rows, err := q.db.Query(ctx, listAcctItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AcctItem{}
	for rows.Next() {
		var i AcctItem
		if err := rows.Scan(
			&i.ID,
			&i.ItemCode,
			&i.ItemName,
			&i.ItemCategory,
			&i.Unit,
			&i.IsInventory,
			&i.IsActive,
			&i.AveragePrice,
			&i.LastPrice,
			&i.ForHpp,
			&i.Keywords,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteAcctItem = `-- name: SoftDeleteAcctItem :one
UPDATE acct_items SET is_active = false WHERE id = $1 AND is_active = true RETURNING id
`

func (q *Queries) SoftDeleteAcctItem(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, softDeleteAcctItem, id)
	err := row.Scan(&id)
	return id, err
}

const updateAcctItem = `-- name: UpdateAcctItem :one
UPDATE acct_items
SET item_name = $2, item_category = $3, unit = $4, is_inventory = $5,
    average_price = $6, last_price = $7, for_hpp = $8, keywords = $9
WHERE id = $1 AND is_active = true
RETURNING id, item_code, item_name, item_category, unit, is_inventory, is_active, average_price, last_price, for_hpp, keywords, created_at
`

type UpdateAcctItemParams struct {
	ID           uuid.UUID      `json:"id"`
	ItemName     string         `json:"item_name"`
	ItemCategory string         `json:"item_category"`
	Unit         string         `json:"unit"`
	IsInventory  bool           `json:"is_inventory"`
	AveragePrice pgtype.Numeric `json:"average_price"`
	LastPrice    pgtype.Numeric `json:"last_price"`
	ForHpp       pgtype.Numeric `json:"for_hpp"`
	Keywords     string         `json:"keywords"`
}

func (q *Queries) UpdateAcctItem(ctx context.Context, arg UpdateAcctItemParams) (AcctItem, error) {
	row := q.db.QueryRow(ctx, updateAcctItem,
		arg.ID,
		arg.ItemName,
		arg.ItemCategory,
		arg.Unit,
		arg.IsInventory,
		arg.AveragePrice,
		arg.LastPrice,
		arg.ForHpp,
		arg.Keywords,
	)
	var i AcctItem
	err := row.Scan(
		&i.ID,
		&i.ItemCode,
		&i.ItemName,
		&i.ItemCategory,
		&i.Unit,
		&i.IsInventory,
		&i.IsActive,
		&i.AveragePrice,
		&i.LastPrice,
		&i.ForHpp,
		&i.Keywords,
		&i.CreatedAt,
	)
	return i, err
}

const updateAcctItemLastPrice = `-- name: UpdateAcctItemLastPrice :exec
UPDATE acct_items SET last_price = $2 WHERE id = $1
`

type UpdateAcctItemLastPriceParams struct {
	ID        uuid.UUID      `json:"id"`
	LastPrice pgtype.Numeric `json:"last_price"`
}

func (q *Queries) UpdateAcctItemLastPrice(ctx context.Context, arg UpdateAcctItemLastPriceParams) error {
	_, err := q.db.Exec(ctx, updateAcctItemLastPrice, arg.ID, arg.LastPrice)
	return err
}
