// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: acct_payroll_entries.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAcctPayrollEntry = `-- name: CreateAcctPayrollEntry :one
INSERT INTO acct_payroll_entries (
    payroll_date, period_type, period_ref, employee_name,
    gross_pay, payment_method, cash_account_id, outlet_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, payroll_date, period_type, period_ref, employee_name, gross_pay, payment_method, cash_account_id, outlet_id, posted_at, created_at
`

type CreateAcctPayrollEntryParams struct {
	PayrollDate   pgtype.Date    `json:"payroll_date"`
	PeriodType    string         `json:"period_type"`
	PeriodRef     pgtype.Text    `json:"period_ref"`
	EmployeeName  string         `json:"employee_name"`
	GrossPay      pgtype.Numeric `json:"gross_pay"`
	PaymentMethod string         `json:"payment_method"`
	CashAccountID uuid.UUID      `json:"cash_account_id"`
	OutletID      pgtype.UUID    `json:"outlet_id"`
}

func (q *Queries) CreateAcctPayrollEntry(ctx context.Context, arg CreateAcctPayrollEntryParams) (AcctPayrollEntry, error) {
	row := q.db.QueryRow(ctx, createAcctPayrollEntry,
		arg.PayrollDate,
		arg.PeriodType,
		arg.PeriodRef,
		arg.EmployeeName,
		arg.GrossPay,
		arg.PaymentMethod,
		arg.CashAccountID,
		arg.OutletID,
	)
	var i AcctPayrollEntry
	err := row.Scan(
		&i.ID,
		&i.PayrollDate,
		&i.PeriodType,
		&i.PeriodRef,
		&i.EmployeeName,
		&i.GrossPay,
		&i.PaymentMethod,
		&i.CashAccountID,
		&i.OutletID,
		&i.PostedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAcctPayrollEntry = `-- name: DeleteAcctPayrollEntry :exec
DELETE FROM acct_payroll_entries WHERE id = $1 AND posted_at IS NULL
`

func (q *Queries) DeleteAcctPayrollEntry(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAcctPayrollEntry, id)
	return err
}

const getAcctPayrollEntry = `-- name: GetAcctPayrollEntry :one
SELECT id, payroll_date, period_type, period_ref, employee_name, gross_pay, payment_method, cash_account_id, outlet_id, posted_at, created_at FROM acct_payroll_entries WHERE id = $1
`

func (q *Queries) GetAcctPayrollEntry(ctx context.Context, id uuid.UUID) (AcctPayrollEntry, error) {
	row := q.db.QueryRow(ctx, getAcctPayrollEntry, id)
	var i AcctPayrollEntry
	err := row.Scan(
		&i.ID,
		&i.PayrollDate,
		&i.PeriodType,
		&i.PeriodRef,
		&i.EmployeeName,
		&i.GrossPay,
		&i.PaymentMethod,
		&i.CashAccountID,
		&i.OutletID,
		&i.PostedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listAcctPayrollEntries = `-- name: ListAcctPayrollEntries :many
SELECT id, payroll_date, period_type, period_ref, employee_name, gross_pay, payment_method, cash_account_id, outlet_id, posted_at, created_at FROM acct_payroll_entries
WHERE
    ($3::date IS NULL OR payroll_date >= $3) AND
    ($4::date IS NULL OR payroll_date <= $4) AND
    ($5::uuid IS NULL OR outlet_id = $5) AND
    ($6::text IS NULL OR period_type = $6)
ORDER BY payroll_date DESC, created_at DESC
LIMIT $1 OFFSET $2
`

type ListAcctPayrollEntriesParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	StartDate  pgtype.Date `json:"start_date"`
	EndDate    pgtype.Date `json:"end_date"`
	OutletID   pgtype.UUID `json:"outlet_id"`
	PeriodType pgtype.Text `json:"period_type"`
}

func (q *Queries) ListAcctPayrollEntries(ctx context.Context, arg ListAcctPayrollEntriesParams) ([]AcctPayrollEntry, error) {
	rows, err := q.db.Query(ctx, listAcctPayrollEntries,
		arg.Limit,
		arg.Offset,
		arg.StartDate,
		arg.EndDate,
		arg.OutletID,
		arg.PeriodType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AcctPayrollEntry{}
	for rows.Next() {
		var i AcctPayrollEntry
		if err := rows.Scan(
			&i.ID,
			&i.PayrollDate,
			&i.PeriodType,
			&i.PeriodRef,
			&i.EmployeeName,
			&i.GrossPay,
			&i.PaymentMethod,
			&i.CashAccountID,
			&i.OutletID,
			&i.PostedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnpostedPayrollEntries = `-- name: ListUnpostedPayrollEntries :many
SELECT id, payroll_date, period_type, period_ref, employee_name, gross_pay, payment_method, cash_account_id, outlet_id, posted_at, created_at FROM acct_payroll_entries
WHERE id = ANY($1::uuid[])
    AND posted_at IS NULL
ORDER BY employee_name
`

func (q *Queries) ListUnpostedPayrollEntries(ctx context.Context, dollar_1 []uuid.UUID) ([]AcctPayrollEntry, error) {
	rows, err := q.db.Query(ctx, listUnpostedPayrollEntries, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AcctPayrollEntry{}
	for rows.Next() {
		var i AcctPayrollEntry
		if err := rows.Scan(
			&i.ID,
			&i.PayrollDate,
			&i.PeriodType,
			&i.PeriodRef,
			&i.EmployeeName,
			&i.GrossPay,
			&i.PaymentMethod,
			&i.CashAccountID,
			&i.OutletID,
			&i.PostedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markPayrollEntriesPosted = `-- name: MarkPayrollEntriesPosted :exec
UPDATE acct_payroll_entries
SET posted_at = now()
WHERE id = ANY($1::uuid[]) AND posted_at IS NULL
`

func (q *Queries) MarkPayrollEntriesPosted(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.Exec(ctx, markPayrollEntriesPosted, dollar_1)
	return err
}

const updateAcctPayrollEntry = `-- name: UpdateAcctPayrollEntry :one
UPDATE acct_payroll_entries
SET payroll_date = $2, period_type = $3, period_ref = $4,
    employee_name = $5, gross_pay = $6, payment_method = $7,
    cash_account_id = $8, outlet_id = $9
WHERE id = $1 AND posted_at IS NULL
RETURNING id, payroll_date, period_type, period_ref, employee_name, gross_pay, payment_method, cash_account_id, outlet_id, posted_at, created_at
`

type UpdateAcctPayrollEntryParams struct {
	ID            uuid.UUID      `json:"id"`
	PayrollDate   pgtype.Date    `json:"payroll_date"`
	PeriodType    string         `json:"period_type"`
	PeriodRef     pgtype.Text    `json:"period_ref"`
	EmployeeName  string         `json:"employee_name"`
	GrossPay      pgtype.Numeric `json:"gross_pay"`
	PaymentMethod string         `json:"payment_method"`
	CashAccountID uuid.UUID      `json:"cash_account_id"`
	OutletID      pgtype.UUID    `json:"outlet_id"`
}

func (q *Queries) UpdateAcctPayrollEntry(ctx context.Context, arg UpdateAcctPayrollEntryParams) (AcctPayrollEntry, error) {
	row := q.db.QueryRow(ctx, updateAcctPayrollEntry,
		arg.ID,
		arg.PayrollDate,
		arg.PeriodType,
		arg.PeriodRef,
		arg.EmployeeName,
		arg.GrossPay,
		arg.PaymentMethod,
		arg.CashAccountID,
		arg.OutletID,
	)
	var i AcctPayrollEntry
	err := row.Scan(
		&i.ID,
		&i.PayrollDate,
		&i.PeriodType,
		&i.PeriodRef,
		&i.EmployeeName,
		&i.GrossPay,
		&i.PaymentMethod,
		&i.CashAccountID,
		&i.OutletID,
		&i.PostedAt,
		&i.CreatedAt,
	)
	return i, err
}
