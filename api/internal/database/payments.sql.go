// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payments.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const completeOrder = `-- name: CompleteOrder :one
UPDATE orders SET status = 'COMPLETED', completed_at = now(), updated_at = now()
WHERE id = $1 AND status != 'CANCELLED'
RETURNING id, outlet_id, order_number, customer_id, order_type, status, table_number, notes, subtotal, discount_type, discount_value, discount_amount, tax_amount, total_amount, catering_date, catering_status, catering_dp_amount, delivery_platform, delivery_address, created_by, created_at, updated_at, completed_at
`

func (q *Queries) CompleteOrder(ctx context.Context, id uuid.UUID) (Order, error) {
	row := q.db.QueryRow(ctx, completeOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OutletID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.OrderType,
		&i.Status,
		&i.TableNumber,
		&i.Notes,
		&i.Subtotal,
		&i.DiscountType,
		&i.DiscountValue,
		&i.DiscountAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.CateringDate,
		&i.CateringStatus,
		&i.CateringDpAmount,
		&i.DeliveryPlatform,
		&i.DeliveryAddress,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    order_id, payment_method, amount, status,
    reference_number, amount_received, change_amount, processed_by
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, order_id, payment_method, amount, status, reference_number, amount_received, change_amount, processed_by, processed_at
`

type CreatePaymentParams struct {
	OrderID         uuid.UUID      `json:"order_id"`
	PaymentMethod   string         `json:"payment_method"`
	Amount          pgtype.Numeric `json:"amount"`
	Status          string         `json:"status"`
	ReferenceNumber pgtype.Text    `json:"reference_number"`
	AmountReceived  pgtype.Numeric `json:"amount_received"`
	ChangeAmount    pgtype.Numeric `json:"change_amount"`
	ProcessedBy     uuid.UUID      `json:"processed_by"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.OrderID,
		arg.PaymentMethod,
		arg.Amount,
		arg.Status,
		arg.ReferenceNumber,
		arg.AmountReceived,
		arg.ChangeAmount,
		arg.ProcessedBy,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.PaymentMethod,
		&i.Amount,
		&i.Status,
		&i.ReferenceNumber,
		&i.AmountReceived,
		&i.ChangeAmount,
		&i.ProcessedBy,
		&i.ProcessedAt,
	)
	return i, err
}

const getOrderForUpdate = `-- name: GetOrderForUpdate :one
SELECT id, outlet_id, order_number, customer_id, order_type, status, table_number, notes, subtotal, discount_type, discount_value, discount_amount, tax_amount, total_amount, catering_date, catering_status, catering_dp_amount, delivery_platform, delivery_address, created_by, created_at, updated_at, completed_at FROM orders WHERE id = $1 AND outlet_id = $2 FOR NO KEY UPDATE
`

type GetOrderForUpdateParams struct {
	ID       uuid.UUID `json:"id"`
	OutletID uuid.UUID `json:"outlet_id"`
}

func (q *Queries) GetOrderForUpdate(ctx context.Context, arg GetOrderForUpdateParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderForUpdate, arg.ID, arg.OutletID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OutletID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.OrderType,
		&i.Status,
		&i.TableNumber,
		&i.Notes,
		&i.Subtotal,
		&i.DiscountType,
		&i.DiscountValue,
		&i.DiscountAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.CateringDate,
		&i.CateringStatus,
		&i.CateringDpAmount,
		&i.DeliveryPlatform,
		&i.DeliveryAddress,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const sumPaymentsByOrder = `-- name: SumPaymentsByOrder :one
SELECT COALESCE(SUM(amount), 0)::decimal(12,2) AS total_paid
FROM payments
WHERE order_id = $1 AND status = 'COMPLETED'
`

func (q *Queries) SumPaymentsByOrder(ctx context.Context, orderID uuid.UUID) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, sumPaymentsByOrder, orderID)
	var total_paid pgtype.Numeric
	err := row.Scan(&total_paid)
	return total_paid, err
}

const updateCateringStatus = `-- name: UpdateCateringStatus :one
UPDATE orders SET catering_status = $2, updated_at = now()
WHERE id = $1
RETURNING id, outlet_id, order_number, customer_id, order_type, status, table_number, notes, subtotal, discount_type, discount_value, discount_amount, tax_amount, total_amount, catering_date, catering_status, catering_dp_amount, delivery_platform, delivery_address, created_by, created_at, updated_at, completed_at
`

type UpdateCateringStatusParams struct {
	ID             uuid.UUID   `json:"id"`
	CateringStatus pgtype.Text `json:"catering_status"`
}

func (q *Queries) UpdateCateringStatus(ctx context.Context, arg UpdateCateringStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateCateringStatus, arg.ID, arg.CateringStatus)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OutletID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.OrderType,
		&i.Status,
		&i.TableNumber,
		&i.Notes,
		&i.Subtotal,
		&i.DiscountType,
		&i.DiscountValue,
		&i.DiscountAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.CateringDate,
		&i.CateringStatus,
		&i.CateringDpAmount,
		&i.DeliveryPlatform,
		&i.DeliveryAddress,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}
