// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: customers.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (outlet_id, name, phone, email, notes)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, outlet_id, name, phone, email, notes, is_active, created_at, updated_at
`

type CreateCustomerParams struct {
	OutletID uuid.UUID   `json:"outlet_id"`
	Name     string      `json:"name"`
	Phone    string      `json:"phone"`
	Email    pgtype.Text `json:"email"`
	Notes    pgtype.Text `json:"notes"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.OutletID,
		arg.Name,
		arg.Phone,
		arg.Email,
		arg.Notes,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.OutletID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Notes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, outlet_id, name, phone, email, notes, is_active, created_at, updated_at FROM customers WHERE id = $1 AND outlet_id = $2 AND is_active = true
`

type GetCustomerParams struct {
	ID       uuid.UUID `json:"id"`
	OutletID uuid.UUID `json:"outlet_id"`
}

func (q *Queries) GetCustomer(ctx context.Context, arg GetCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomer, arg.ID, arg.OutletID)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.OutletID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Notes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerStats = `-- name: GetCustomerStats :one
SELECT
    COUNT(DISTINCT o.id) AS total_orders,
    COALESCE(SUM(o.total_amount), 0)::decimal(12,2) AS total_spend,
    COALESCE(AVG(o.total_amount), 0)::decimal(12,2) AS avg_ticket
FROM orders o
WHERE o.customer_id = $1 AND o.outlet_id = $2 AND o.status != 'CANCELLED'
`

type GetCustomerStatsParams struct {
	CustomerID pgtype.UUID `json:"customer_id"`
	OutletID   uuid.UUID   `json:"outlet_id"`
}

type GetCustomerStatsRow struct {
	TotalOrders int64          `json:"total_orders"`
	TotalSpend  pgtype.Numeric `json:"total_spend"`
	AvgTicket   pgtype.Numeric `json:"avg_ticket"`
}

func (q *Queries) GetCustomerStats(ctx context.Context, arg GetCustomerStatsParams) (GetCustomerStatsRow, error) {
	row := q.db.QueryRow(ctx, getCustomerStats, arg.CustomerID, arg.OutletID)
	var i GetCustomerStatsRow
	err := row.Scan(&i.TotalOrders, &i.TotalSpend, &i.AvgTicket)
	return i, err
}

const getCustomerTopItems = `-- name: GetCustomerTopItems :many
SELECT p.id AS product_id, p.name AS product_name,
    SUM(oi.quantity) AS total_qty,
    SUM(oi.subtotal)::decimal(12,2) AS total_revenue
FROM order_items oi
JOIN orders o ON o.id = oi.order_id
JOIN products p ON p.id = oi.product_id
WHERE o.customer_id = $1 AND o.outlet_id = $2 AND o.status != 'CANCELLED'
GROUP BY p.id, p.name
ORDER BY total_qty DESC
LIMIT 5
`

type GetCustomerTopItemsParams struct {
	CustomerID pgtype.UUID `json:"customer_id"`
	OutletID   uuid.UUID   `json:"outlet_id"`
}

type GetCustomerTopItemsRow struct {
	ProductID    uuid.UUID      `json:"product_id"`
	ProductName  string         `json:"product_name"`
	TotalQty     int64          `json:"total_qty"`
	TotalRevenue pgtype.Numeric `json:"total_revenue"`
}

func (q *Queries) GetCustomerTopItems(ctx context.Context, arg GetCustomerTopItemsParams) ([]GetCustomerTopItemsRow, error) {
	rows, err := q.db.Query(ctx, getCustomerTopItems, arg.CustomerID, arg.OutletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCustomerTopItemsRow{}
	for rows.Next() {
		var i GetCustomerTopItemsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.TotalQty,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomerOrders = `-- name: ListCustomerOrders :many
SELECT id, outlet_id, order_number, customer_id, order_type, status, table_number, notes, subtotal, discount_type, discount_value, discount_amount, tax_amount, total_amount, catering_date, catering_status, catering_dp_amount, delivery_platform, delivery_address, created_by, created_at, updated_at, completed_at FROM orders
WHERE customer_id = $1 AND outlet_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListCustomerOrdersParams struct {
	CustomerID pgtype.UUID `json:"customer_id"`
	OutletID   uuid.UUID   `json:"outlet_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

func (q *Queries) ListCustomerOrders(ctx context.Context, arg ListCustomerOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listCustomerOrders,
		arg.CustomerID,
		arg.OutletID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.OutletID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.OrderType,
			&i.Status,
			&i.TableNumber,
			&i.Notes,
			&i.Subtotal,
			&i.DiscountType,
			&i.DiscountValue,
			&i.DiscountAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.CateringDate,
			&i.CateringStatus,
			&i.CateringDpAmount,
			&i.DeliveryPlatform,
			&i.DeliveryAddress,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomersByOutlet = `-- name: ListCustomersByOutlet :many
SELECT id, outlet_id, name, phone, email, notes, is_active, created_at, updated_at FROM customers
WHERE outlet_id = $1 AND is_active = true
  AND ($4::text IS NULL OR phone LIKE '%' || $4::text || '%' OR name ILIKE '%' || $4::text || '%')
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListCustomersByOutletParams struct {
	OutletID uuid.UUID   `json:"outlet_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
	Search   pgtype.Text `json:"search"`
}

func (q *Queries) ListCustomersByOutlet(ctx context.Context, arg ListCustomersByOutletParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listCustomersByOutlet,
		arg.OutletID,
		arg.Limit,
		arg.Offset,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.OutletID,
			&i.Name,
			&i.Phone,
			&i.Email,
			&i.Notes,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteCustomer = `-- name: SoftDeleteCustomer :one
UPDATE customers SET is_active = false, updated_at = now()
WHERE id = $1 AND outlet_id = $2 AND is_active = true
RETURNING id
`

type SoftDeleteCustomerParams struct {
	ID       uuid.UUID `json:"id"`
	OutletID uuid.UUID `json:"outlet_id"`
}

func (q *Queries) SoftDeleteCustomer(ctx context.Context, arg SoftDeleteCustomerParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, softDeleteCustomer, arg.ID, arg.OutletID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customers SET name = $2, phone = $3, email = $4, notes = $5, updated_at = now()
WHERE id = $1 AND outlet_id = $6 AND is_active = true
RETURNING id, outlet_id, name, phone, email, notes, is_active, created_at, updated_at
`

type UpdateCustomerParams struct {
	ID       uuid.UUID   `json:"id"`
	Name     string      `json:"name"`
	Phone    string      `json:"phone"`
	Email    pgtype.Text `json:"email"`
	Notes    pgtype.Text `json:"notes"`
	OutletID uuid.UUID   `json:"outlet_id"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, updateCustomer,
		arg.ID,
		arg.Name,
		arg.Phone,
		arg.Email,
		arg.Notes,
		arg.OutletID,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.OutletID,
		&i.Name,
		&i.Phone,
		&i.Email,
		&i.Notes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
