// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: acct_sales_daily_summaries.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const aggregatePOSSales = `-- name: AggregatePOSSales :many
SELECT
    o.completed_at::date AS sales_date,
    o.order_type,
    p.payment_method,
    SUM(p.amount)::text AS total_amount
FROM orders o
JOIN payments p ON p.order_id = o.id
WHERE o.status = 'COMPLETED'
    AND p.status = 'COMPLETED'
    AND o.outlet_id = $1
    AND o.completed_at::date >= $2::date
    AND o.completed_at::date <= $3::date
GROUP BY o.completed_at::date, o.order_type, p.payment_method
ORDER BY 1, 2, 3
`

type AggregatePOSSalesParams struct {
	OutletID uuid.UUID   `json:"outlet_id"`
	Column2  pgtype.Date `json:"column_2"`
	Column3  pgtype.Date `json:"column_3"`
}

type AggregatePOSSalesRow struct {
	SalesDate     pgtype.Date `json:"sales_date"`
	OrderType     string      `json:"order_type"`
	PaymentMethod string      `json:"payment_method"`
	TotalAmount   string      `json:"total_amount"`
}

// Cross-domain query: aggregates completed POS orders by date, order_type, payment_method.
// Handler maps order_type → channel name and payment_method → display name.
func (q *Queries) AggregatePOSSales(ctx context.Context, arg AggregatePOSSalesParams) ([]AggregatePOSSalesRow, error) {
	rows, err := q.db.Query(ctx, aggregatePOSSales, arg.OutletID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AggregatePOSSalesRow{}
	for rows.Next() {
		var i AggregatePOSSalesRow
		if err := rows.Scan(
			&i.SalesDate,
			&i.OrderType,
			&i.PaymentMethod,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createAcctSalesDailySummary = `-- name: CreateAcctSalesDailySummary :one
INSERT INTO acct_sales_daily_summaries (
    sales_date, channel, payment_method,
    gross_sales, discount_amount, net_sales,
    cash_account_id, outlet_id, source
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, sales_date, channel, payment_method, gross_sales, discount_amount, net_sales, cash_account_id, outlet_id, source, created_at, posted_at
`

type CreateAcctSalesDailySummaryParams struct {
	SalesDate      pgtype.Date    `json:"sales_date"`
	Channel        string         `json:"channel"`
	PaymentMethod  string         `json:"payment_method"`
	GrossSales     pgtype.Numeric `json:"gross_sales"`
	DiscountAmount pgtype.Numeric `json:"discount_amount"`
	NetSales       pgtype.Numeric `json:"net_sales"`
	CashAccountID  uuid.UUID      `json:"cash_account_id"`
	OutletID       pgtype.UUID    `json:"outlet_id"`
	Source         string         `json:"source"`
}

func (q *Queries) CreateAcctSalesDailySummary(ctx context.Context, arg CreateAcctSalesDailySummaryParams) (AcctSalesDailySummary, error) {
	row := q.db.QueryRow(ctx, createAcctSalesDailySummary,
		arg.SalesDate,
		arg.Channel,
		arg.PaymentMethod,
		arg.GrossSales,
		arg.DiscountAmount,
		arg.NetSales,
		arg.CashAccountID,
		arg.OutletID,
		arg.Source,
	)
	var i AcctSalesDailySummary
	err := row.Scan(
		&i.ID,
		&i.SalesDate,
		&i.Channel,
		&i.PaymentMethod,
		&i.GrossSales,
		&i.DiscountAmount,
		&i.NetSales,
		&i.CashAccountID,
		&i.OutletID,
		&i.Source,
		&i.CreatedAt,
		&i.PostedAt,
	)
	return i, err
}

const deleteAcctSalesDailySummary = `-- name: DeleteAcctSalesDailySummary :exec
DELETE FROM acct_sales_daily_summaries
WHERE id = $1 AND source = 'manual' AND posted_at IS NULL
`

func (q *Queries) DeleteAcctSalesDailySummary(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAcctSalesDailySummary, id)
	return err
}

const getAcctSalesDailySummary = `-- name: GetAcctSalesDailySummary :one
SELECT id, sales_date, channel, payment_method, gross_sales, discount_amount, net_sales, cash_account_id, outlet_id, source, created_at, posted_at FROM acct_sales_daily_summaries WHERE id = $1
`

func (q *Queries) GetAcctSalesDailySummary(ctx context.Context, id uuid.UUID) (AcctSalesDailySummary, error) {
	row := q.db.QueryRow(ctx, getAcctSalesDailySummary, id)
	var i AcctSalesDailySummary
	err := row.Scan(
		&i.ID,
		&i.SalesDate,
		&i.Channel,
		&i.PaymentMethod,
		&i.GrossSales,
		&i.DiscountAmount,
		&i.NetSales,
		&i.CashAccountID,
		&i.OutletID,
		&i.Source,
		&i.CreatedAt,
		&i.PostedAt,
	)
	return i, err
}

const listAcctSalesDailySummaries = `-- name: ListAcctSalesDailySummaries :many
SELECT id, sales_date, channel, payment_method, gross_sales, discount_amount, net_sales, cash_account_id, outlet_id, source, created_at, posted_at FROM acct_sales_daily_summaries
WHERE
    ($3::date IS NULL OR sales_date >= $3) AND
    ($4::date IS NULL OR sales_date <= $4) AND
    ($5::text IS NULL OR channel = $5) AND
    ($6::uuid IS NULL OR outlet_id = $6)
ORDER BY sales_date DESC, channel, payment_method
LIMIT $1 OFFSET $2
`

type ListAcctSalesDailySummariesParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	Channel   pgtype.Text `json:"channel"`
	OutletID  pgtype.UUID `json:"outlet_id"`
}

func (q *Queries) ListAcctSalesDailySummaries(ctx context.Context, arg ListAcctSalesDailySummariesParams) ([]AcctSalesDailySummary, error) {
	rows, err := q.db.Query(ctx, listAcctSalesDailySummaries,
		arg.Limit,
		arg.Offset,
		arg.StartDate,
		arg.EndDate,
		arg.Channel,
		arg.OutletID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AcctSalesDailySummary{}
	for rows.Next() {
		var i AcctSalesDailySummary
		if err := rows.Scan(
			&i.ID,
			&i.SalesDate,
			&i.Channel,
			&i.PaymentMethod,
			&i.GrossSales,
			&i.DiscountAmount,
			&i.NetSales,
			&i.CashAccountID,
			&i.OutletID,
			&i.Source,
			&i.CreatedAt,
			&i.PostedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnpostedSalesSummaries = `-- name: ListUnpostedSalesSummaries :many
SELECT id, sales_date, channel, payment_method, gross_sales, discount_amount, net_sales, cash_account_id, outlet_id, source, created_at, posted_at FROM acct_sales_daily_summaries
WHERE sales_date = $1
    AND ($2::uuid IS NULL OR outlet_id = $2)
    AND posted_at IS NULL
ORDER BY channel, payment_method
`

type ListUnpostedSalesSummariesParams struct {
	SalesDate pgtype.Date `json:"sales_date"`
	OutletID  pgtype.UUID `json:"outlet_id"`
}

// Get unposted summaries for a specific date + optional outlet for posting.
func (q *Queries) ListUnpostedSalesSummaries(ctx context.Context, arg ListUnpostedSalesSummariesParams) ([]AcctSalesDailySummary, error) {
	rows, err := q.db.Query(ctx, listUnpostedSalesSummaries, arg.SalesDate, arg.OutletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AcctSalesDailySummary{}
	for rows.Next() {
		var i AcctSalesDailySummary
		if err := rows.Scan(
			&i.ID,
			&i.SalesDate,
			&i.Channel,
			&i.PaymentMethod,
			&i.GrossSales,
			&i.DiscountAmount,
			&i.NetSales,
			&i.CashAccountID,
			&i.OutletID,
			&i.Source,
			&i.CreatedAt,
			&i.PostedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSalesSummariesPosted = `-- name: MarkSalesSummariesPosted :exec
UPDATE acct_sales_daily_summaries
SET posted_at = now()
WHERE sales_date = $1
    AND ($2::uuid IS NULL OR outlet_id = $2)
    AND posted_at IS NULL
`

type MarkSalesSummariesPostedParams struct {
	SalesDate pgtype.Date `json:"sales_date"`
	OutletID  pgtype.UUID `json:"outlet_id"`
}

// Batch-mark summaries as posted for a given date + outlet.
func (q *Queries) MarkSalesSummariesPosted(ctx context.Context, arg MarkSalesSummariesPostedParams) error {
	_, err := q.db.Exec(ctx, markSalesSummariesPosted, arg.SalesDate, arg.OutletID)
	return err
}

const updateAcctSalesDailySummary = `-- name: UpdateAcctSalesDailySummary :one
UPDATE acct_sales_daily_summaries
SET channel = $2, payment_method = $3,
    gross_sales = $4, discount_amount = $5, net_sales = $6,
    cash_account_id = $7
WHERE id = $1 AND source = 'manual' AND posted_at IS NULL
RETURNING id, sales_date, channel, payment_method, gross_sales, discount_amount, net_sales, cash_account_id, outlet_id, source, created_at, posted_at
`

type UpdateAcctSalesDailySummaryParams struct {
	ID             uuid.UUID      `json:"id"`
	Channel        string         `json:"channel"`
	PaymentMethod  string         `json:"payment_method"`
	GrossSales     pgtype.Numeric `json:"gross_sales"`
	DiscountAmount pgtype.Numeric `json:"discount_amount"`
	NetSales       pgtype.Numeric `json:"net_sales"`
	CashAccountID  uuid.UUID      `json:"cash_account_id"`
}

func (q *Queries) UpdateAcctSalesDailySummary(ctx context.Context, arg UpdateAcctSalesDailySummaryParams) (AcctSalesDailySummary, error) {
	row := q.db.QueryRow(ctx, updateAcctSalesDailySummary,
		arg.ID,
		arg.Channel,
		arg.PaymentMethod,
		arg.GrossSales,
		arg.DiscountAmount,
		arg.NetSales,
		arg.CashAccountID,
	)
	var i AcctSalesDailySummary
	err := row.Scan(
		&i.ID,
		&i.SalesDate,
		&i.Channel,
		&i.PaymentMethod,
		&i.GrossSales,
		&i.DiscountAmount,
		&i.NetSales,
		&i.CashAccountID,
		&i.OutletID,
		&i.Source,
		&i.CreatedAt,
		&i.PostedAt,
	)
	return i, err
}

const upsertAcctSalesDailySummary = `-- name: UpsertAcctSalesDailySummary :one
INSERT INTO acct_sales_daily_summaries (
    sales_date, channel, payment_method,
    gross_sales, discount_amount, net_sales,
    cash_account_id, outlet_id, source
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'pos')
ON CONFLICT (sales_date, channel, payment_method, outlet_id)
DO UPDATE SET
    gross_sales = EXCLUDED.gross_sales,
    discount_amount = EXCLUDED.discount_amount,
    net_sales = EXCLUDED.net_sales,
    cash_account_id = EXCLUDED.cash_account_id
WHERE acct_sales_daily_summaries.posted_at IS NULL
RETURNING id, sales_date, channel, payment_method, gross_sales, discount_amount, net_sales, cash_account_id, outlet_id, source, created_at, posted_at
`

type UpsertAcctSalesDailySummaryParams struct {
	SalesDate      pgtype.Date    `json:"sales_date"`
	Channel        string         `json:"channel"`
	PaymentMethod  string         `json:"payment_method"`
	GrossSales     pgtype.Numeric `json:"gross_sales"`
	DiscountAmount pgtype.Numeric `json:"discount_amount"`
	NetSales       pgtype.Numeric `json:"net_sales"`
	CashAccountID  uuid.UUID      `json:"cash_account_id"`
	OutletID       pgtype.UUID    `json:"outlet_id"`
}

// Used by POS sync — upserts by the UNIQUE(sales_date, channel, payment_method, outlet_id) constraint.
// Only updates if not yet posted.
func (q *Queries) UpsertAcctSalesDailySummary(ctx context.Context, arg UpsertAcctSalesDailySummaryParams) (AcctSalesDailySummary, error) {
	row := q.db.QueryRow(ctx, upsertAcctSalesDailySummary,
		arg.SalesDate,
		arg.Channel,
		arg.PaymentMethod,
		arg.GrossSales,
		arg.DiscountAmount,
		arg.NetSales,
		arg.CashAccountID,
		arg.OutletID,
	)
	var i AcctSalesDailySummary
	err := row.Scan(
		&i.ID,
		&i.SalesDate,
		&i.Channel,
		&i.PaymentMethod,
		&i.GrossSales,
		&i.DiscountAmount,
		&i.NetSales,
		&i.CashAccountID,
		&i.OutletID,
		&i.Source,
		&i.CreatedAt,
		&i.PostedAt,
	)
	return i, err
}
