// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: acct_reimbursement_requests.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const assignReimbursementBatch = `-- name: AssignReimbursementBatch :exec
UPDATE acct_reimbursement_requests
SET batch_id = $1, status = 'Ready'
WHERE id = $2 AND status = 'Draft'
`

type AssignReimbursementBatchParams struct {
	BatchID pgtype.Text `json:"batch_id"`
	ID      uuid.UUID   `json:"id"`
}

func (q *Queries) AssignReimbursementBatch(ctx context.Context, arg AssignReimbursementBatchParams) error {
	_, err := q.db.Exec(ctx, assignReimbursementBatch, arg.BatchID, arg.ID)
	return err
}

const checkBatchPosted = `-- name: CheckBatchPosted :one
SELECT EXISTS(
    SELECT 1 FROM acct_reimbursement_requests
    WHERE batch_id = $1 AND status = 'Posted'
)::boolean AS is_posted
`

func (q *Queries) CheckBatchPosted(ctx context.Context, batchID pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, checkBatchPosted, batchID)
	var is_posted bool
	err := row.Scan(&is_posted)
	return is_posted, err
}

const createAcctReimbursementRequest = `-- name: CreateAcctReimbursementRequest :one
INSERT INTO acct_reimbursement_requests (
    expense_date, item_id, description, qty, unit_price, amount,
    line_type, account_id, status, requester, receipt_link
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, batch_id, expense_date, item_id, description, qty, unit_price, amount, line_type, account_id, status, requester, receipt_link, posted_at, created_at
`

type CreateAcctReimbursementRequestParams struct {
	ExpenseDate pgtype.Date    `json:"expense_date"`
	ItemID      pgtype.UUID    `json:"item_id"`
	Description string         `json:"description"`
	Qty         pgtype.Numeric `json:"qty"`
	UnitPrice   pgtype.Numeric `json:"unit_price"`
	Amount      pgtype.Numeric `json:"amount"`
	LineType    string         `json:"line_type"`
	AccountID   uuid.UUID      `json:"account_id"`
	Status      string         `json:"status"`
	Requester   string         `json:"requester"`
	ReceiptLink pgtype.Text    `json:"receipt_link"`
}

func (q *Queries) CreateAcctReimbursementRequest(ctx context.Context, arg CreateAcctReimbursementRequestParams) (AcctReimbursementRequest, error) {
	row := q.db.QueryRow(ctx, createAcctReimbursementRequest,
		arg.ExpenseDate,
		arg.ItemID,
		arg.Description,
		arg.Qty,
		arg.UnitPrice,
		arg.Amount,
		arg.LineType,
		arg.AccountID,
		arg.Status,
		arg.Requester,
		arg.ReceiptLink,
	)
	var i AcctReimbursementRequest
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.ExpenseDate,
		&i.ItemID,
		&i.Description,
		&i.Qty,
		&i.UnitPrice,
		&i.Amount,
		&i.LineType,
		&i.AccountID,
		&i.Status,
		&i.Requester,
		&i.ReceiptLink,
		&i.PostedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAcctReimbursementRequest = `-- name: DeleteAcctReimbursementRequest :one
DELETE FROM acct_reimbursement_requests
WHERE id = $1 AND status = 'Draft'
RETURNING id
`

func (q *Queries) DeleteAcctReimbursementRequest(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteAcctReimbursementRequest, id)
	err := row.Scan(&id)
	return id, err
}

const getAcctReimbursementRequest = `-- name: GetAcctReimbursementRequest :one
SELECT id, batch_id, expense_date, item_id, description, qty, unit_price, amount, line_type, account_id, status, requester, receipt_link, posted_at, created_at FROM acct_reimbursement_requests WHERE id = $1
`

func (q *Queries) GetAcctReimbursementRequest(ctx context.Context, id uuid.UUID) (AcctReimbursementRequest, error) {
	row := q.db.QueryRow(ctx, getAcctReimbursementRequest, id)
	var i AcctReimbursementRequest
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.ExpenseDate,
		&i.ItemID,
		&i.Description,
		&i.Qty,
		&i.UnitPrice,
		&i.Amount,
		&i.LineType,
		&i.AccountID,
		&i.Status,
		&i.Requester,
		&i.ReceiptLink,
		&i.PostedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getNextBatchCode = `-- name: GetNextBatchCode :one
SELECT COALESCE(MAX(batch_id), 'RMB000')::text AS max_code
FROM acct_reimbursement_requests
WHERE batch_id IS NOT NULL
`

func (q *Queries) GetNextBatchCode(ctx context.Context) (string, error) {
	row := q.db.QueryRow(ctx, getNextBatchCode)
	var max_code string
	err := row.Scan(&max_code)
	return max_code, err
}

const listAcctReimbursementRequests = `-- name: ListAcctReimbursementRequests :many
SELECT id, batch_id, expense_date, item_id, description, qty, unit_price, amount, line_type, account_id, status, requester, receipt_link, posted_at, created_at FROM acct_reimbursement_requests
WHERE
    ($3::text IS NULL OR status = $3) AND
    ($4::text IS NULL OR requester = $4) AND
    ($5::text IS NULL OR batch_id = $5) AND
    ($6::date IS NULL OR expense_date >= $6) AND
    ($7::date IS NULL OR expense_date <= $7)
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAcctReimbursementRequestsParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	Status    pgtype.Text `json:"status"`
	Requester pgtype.Text `json:"requester"`
	BatchID   pgtype.Text `json:"batch_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

func (q *Queries) ListAcctReimbursementRequests(ctx context.Context, arg ListAcctReimbursementRequestsParams) ([]AcctReimbursementRequest, error) {
	rows, err := q.db.Query(ctx, listAcctReimbursementRequests,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.Requester,
		arg.BatchID,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AcctReimbursementRequest{}
	for rows.Next() {
		var i AcctReimbursementRequest
		if err := rows.Scan(
			&i.ID,
			&i.BatchID,
			&i.ExpenseDate,
			&i.ItemID,
			&i.Description,
			&i.Qty,
			&i.UnitPrice,
			&i.Amount,
			&i.LineType,
			&i.AccountID,
			&i.Status,
			&i.Requester,
			&i.ReceiptLink,
			&i.PostedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReimbursementsByBatch = `-- name: ListReimbursementsByBatch :many
SELECT id, batch_id, expense_date, item_id, description, qty, unit_price, amount, line_type, account_id, status, requester, receipt_link, posted_at, created_at FROM acct_reimbursement_requests
WHERE batch_id = $1
ORDER BY created_at
`

func (q *Queries) ListReimbursementsByBatch(ctx context.Context, batchID pgtype.Text) ([]AcctReimbursementRequest, error) {
	rows, err := q.db.Query(ctx, listReimbursementsByBatch, batchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AcctReimbursementRequest{}
	for rows.Next() {
		var i AcctReimbursementRequest
		if err := rows.Scan(
			&i.ID,
			&i.BatchID,
			&i.ExpenseDate,
			&i.ItemID,
			&i.Description,
			&i.Qty,
			&i.UnitPrice,
			&i.Amount,
			&i.LineType,
			&i.AccountID,
			&i.Status,
			&i.Requester,
			&i.ReceiptLink,
			&i.PostedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postReimbursementBatch = `-- name: PostReimbursementBatch :exec
UPDATE acct_reimbursement_requests
SET status = 'Posted', posted_at = now()
WHERE batch_id = $1 AND status = 'Ready'
`

func (q *Queries) PostReimbursementBatch(ctx context.Context, batchID pgtype.Text) error {
	_, err := q.db.Exec(ctx, postReimbursementBatch, batchID)
	return err
}

const updateAcctReimbursementRequest = `-- name: UpdateAcctReimbursementRequest :one
UPDATE acct_reimbursement_requests
SET expense_date = $2, item_id = $3, description = $4, qty = $5, unit_price = $6,
    amount = $7, line_type = $8, account_id = $9, status = $10, receipt_link = $11
WHERE id = $1 AND status != 'Posted'
RETURNING id, batch_id, expense_date, item_id, description, qty, unit_price, amount, line_type, account_id, status, requester, receipt_link, posted_at, created_at
`

type UpdateAcctReimbursementRequestParams struct {
	ID          uuid.UUID      `json:"id"`
	ExpenseDate pgtype.Date    `json:"expense_date"`
	ItemID      pgtype.UUID    `json:"item_id"`
	Description string         `json:"description"`
	Qty         pgtype.Numeric `json:"qty"`
	UnitPrice   pgtype.Numeric `json:"unit_price"`
	Amount      pgtype.Numeric `json:"amount"`
	LineType    string         `json:"line_type"`
	AccountID   uuid.UUID      `json:"account_id"`
	Status      string         `json:"status"`
	ReceiptLink pgtype.Text    `json:"receipt_link"`
}

func (q *Queries) UpdateAcctReimbursementRequest(ctx context.Context, arg UpdateAcctReimbursementRequestParams) (AcctReimbursementRequest, error) {
	row := q.db.QueryRow(ctx, updateAcctReimbursementRequest,
		arg.ID,
		arg.ExpenseDate,
		arg.ItemID,
		arg.Description,
		arg.Qty,
		arg.UnitPrice,
		arg.Amount,
		arg.LineType,
		arg.AccountID,
		arg.Status,
		arg.ReceiptLink,
	)
	var i AcctReimbursementRequest
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.ExpenseDate,
		&i.ItemID,
		&i.Description,
		&i.Qty,
		&i.UnitPrice,
		&i.Amount,
		&i.LineType,
		&i.AccountID,
		&i.Status,
		&i.Requester,
		&i.ReceiptLink,
		&i.PostedAt,
		&i.CreatedAt,
	)
	return i, err
}
