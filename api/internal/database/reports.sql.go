// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reports.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getDailySales = `-- name: GetDailySales :many
SELECT
    DATE(o.created_at) AS sale_date,
    COUNT(o.id) AS order_count,
    SUM(o.total_amount)::decimal(12,2) AS total_revenue,
    SUM(o.discount_amount)::decimal(12,2) AS total_discount,
    (SUM(o.total_amount) - SUM(o.discount_amount))::decimal(12,2) AS net_revenue
FROM orders o
WHERE o.outlet_id = $1
    AND o.status != 'CANCELLED'
    AND o.created_at >= $2
    AND o.created_at < $3
GROUP BY DATE(o.created_at)
ORDER BY sale_date
`

type GetDailySalesParams struct {
	OutletID    uuid.UUID `json:"outlet_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetDailySalesRow struct {
	SaleDate      pgtype.Date    `json:"sale_date"`
	OrderCount    int64          `json:"order_count"`
	TotalRevenue  pgtype.Numeric `json:"total_revenue"`
	TotalDiscount pgtype.Numeric `json:"total_discount"`
	NetRevenue    pgtype.Numeric `json:"net_revenue"`
}

func (q *Queries) GetDailySales(ctx context.Context, arg GetDailySalesParams) ([]GetDailySalesRow, error) {
	rows, err := q.db.Query(ctx, getDailySales, arg.OutletID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailySalesRow{}
	for rows.Next() {
		var i GetDailySalesRow
		if err := rows.Scan(
			&i.SaleDate,
			&i.OrderCount,
			&i.TotalRevenue,
			&i.TotalDiscount,
			&i.NetRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHourlySales = `-- name: GetHourlySales :many
SELECT
    EXTRACT(HOUR FROM o.created_at)::int AS hour,
    COUNT(o.id) AS order_count,
    SUM(o.total_amount)::decimal(12,2) AS total_revenue
FROM orders o
WHERE o.outlet_id = $1
    AND o.status != 'CANCELLED'
    AND o.created_at >= $2
    AND o.created_at < $3
GROUP BY EXTRACT(HOUR FROM o.created_at)
ORDER BY hour
`

type GetHourlySalesParams struct {
	OutletID    uuid.UUID `json:"outlet_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetHourlySalesRow struct {
	Hour         int32          `json:"hour"`
	OrderCount   int64          `json:"order_count"`
	TotalRevenue pgtype.Numeric `json:"total_revenue"`
}

func (q *Queries) GetHourlySales(ctx context.Context, arg GetHourlySalesParams) ([]GetHourlySalesRow, error) {
	rows, err := q.db.Query(ctx, getHourlySales, arg.OutletID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHourlySalesRow{}
	for rows.Next() {
		var i GetHourlySalesRow
		if err := rows.Scan(&i.Hour, &i.OrderCount, &i.TotalRevenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutletComparison = `-- name: GetOutletComparison :many
SELECT
    outlets.id AS outlet_id,
    outlets.name AS outlet_name,
    COUNT(o.id) AS order_count,
    COALESCE(SUM(o.total_amount), 0)::decimal(12,2) AS total_revenue
FROM outlets
LEFT JOIN orders o ON o.outlet_id = outlets.id
    AND o.status != 'CANCELLED'
    AND o.created_at >= $1
    AND o.created_at < $2
WHERE outlets.is_active = true
GROUP BY outlets.id, outlets.name
ORDER BY total_revenue DESC
`

type GetOutletComparisonParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetOutletComparisonRow struct {
	OutletID     uuid.UUID      `json:"outlet_id"`
	OutletName   string         `json:"outlet_name"`
	OrderCount   int64          `json:"order_count"`
	TotalRevenue pgtype.Numeric `json:"total_revenue"`
}

func (q *Queries) GetOutletComparison(ctx context.Context, arg GetOutletComparisonParams) ([]GetOutletComparisonRow, error) {
	rows, err := q.db.Query(ctx, getOutletComparison, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOutletComparisonRow{}
	for rows.Next() {
		var i GetOutletComparisonRow
		if err := rows.Scan(
			&i.OutletID,
			&i.OutletName,
			&i.OrderCount,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentSummary = `-- name: GetPaymentSummary :many
SELECT
    p.payment_method,
    COUNT(p.id) AS transaction_count,
    SUM(p.amount)::decimal(12,2) AS total_amount
FROM payments p
JOIN orders o ON o.id = p.order_id
WHERE o.outlet_id = $1
    AND o.status != 'CANCELLED'
    AND p.processed_at >= $2
    AND p.processed_at < $3
GROUP BY p.payment_method
ORDER BY p.payment_method
`

type GetPaymentSummaryParams struct {
	OutletID      uuid.UUID `json:"outlet_id"`
	ProcessedAt   time.Time `json:"processed_at"`
	ProcessedAt_2 time.Time `json:"processed_at_2"`
}

type GetPaymentSummaryRow struct {
	PaymentMethod    PaymentMethod  `json:"payment_method"`
	TransactionCount int64          `json:"transaction_count"`
	TotalAmount      pgtype.Numeric `json:"total_amount"`
}

func (q *Queries) GetPaymentSummary(ctx context.Context, arg GetPaymentSummaryParams) ([]GetPaymentSummaryRow, error) {
	rows, err := q.db.Query(ctx, getPaymentSummary, arg.OutletID, arg.ProcessedAt, arg.ProcessedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentSummaryRow{}
	for rows.Next() {
		var i GetPaymentSummaryRow
		if err := rows.Scan(&i.PaymentMethod, &i.TransactionCount, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductSales = `-- name: GetProductSales :many
SELECT
    p.id AS product_id,
    p.name AS product_name,
    SUM(oi.quantity) AS quantity_sold,
    SUM(oi.subtotal)::decimal(12,2) AS total_revenue
FROM order_items oi
JOIN orders o ON o.id = oi.order_id
JOIN products p ON p.id = oi.product_id
WHERE o.outlet_id = $1
    AND o.status != 'CANCELLED'
    AND o.created_at >= $2
    AND o.created_at < $3
GROUP BY p.id, p.name
ORDER BY quantity_sold DESC
LIMIT $4
`

type GetProductSalesParams struct {
	OutletID    uuid.UUID `json:"outlet_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
}

type GetProductSalesRow struct {
	ProductID    uuid.UUID      `json:"product_id"`
	ProductName  string         `json:"product_name"`
	QuantitySold int64          `json:"quantity_sold"`
	TotalRevenue pgtype.Numeric `json:"total_revenue"`
}

func (q *Queries) GetProductSales(ctx context.Context, arg GetProductSalesParams) ([]GetProductSalesRow, error) {
	rows, err := q.db.Query(ctx, getProductSales,
		arg.OutletID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductSalesRow{}
	for rows.Next() {
		var i GetProductSalesRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.QuantitySold,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
