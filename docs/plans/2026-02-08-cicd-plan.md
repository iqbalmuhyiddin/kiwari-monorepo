# CI/CD Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Set up GitHub Actions CI/CD that deploys to staging on push to main and to production on tag.

**Architecture:** Path-filtered workflows per service (API, admin). Build Docker images in CI, push to ghcr.io, SSH to VPS to pull and restart. Single shared PostgreSQL on VPS with separate databases per environment.

**Tech Stack:** GitHub Actions, ghcr.io, Docker Compose, SSH (appleboy/ssh-action), PostgreSQL 16

**Registry:** `ghcr.io/iqbalmuhyiddin/kiwari-api`, `ghcr.io/iqbalmuhyiddin/kiwari-admin`

---

### Task 1: Update CORS for new domains

The API currently only allows `localhost:5173` and `pos.nasibakarkiwari.com`. The new staging and production domains need to be added.

**Files:**
- Modify: `api/internal/router/router.go:29-33`

**Step 1: Update AllowedOrigins**

In `api/internal/router/router.go`, replace the CORS AllowedOrigins block:

```go
AllowedOrigins: []string{
    "http://localhost:5173",                  // SvelteKit dev server
    "https://admin.nasibakarkiwari.com",      // Production admin
    "https://stg-admin.nasibakarkiwari.com",  // Staging admin
},
```

**Step 2: Run tests**

```bash
cd api && go test ./... -count=1
```

Expected: All tests pass.

**Step 3: Commit**

```bash
git add api/internal/router/router.go
git commit -m "feat: update CORS origins for staging and production domains"
```

---

### Task 2: Create API CI workflow (staging)

**Files:**
- Create: `.github/workflows/api-ci.yml`

**Step 1: Create the workflow file**

```yaml
name: API CI

on:
  push:
    branches: [main]
    paths:
      - 'api/**'
      - 'docker/Dockerfile.api'
  workflow_call:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: iqbalmuhyiddin/kiwari-api

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version-file: api/go.mod

      - name: Run tests
        working-directory: api
        run: go test ./... -count=1

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Log in to ghcr.io
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.api
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging

  deploy-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Deploy to staging
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            echo ${{ secrets.GHCR_TOKEN }} | docker login ghcr.io -u iqbalmuhyiddin --password-stdin
            cd ~/docker/pos-staging
            docker compose pull pos-api-staging
            docker compose up -d pos-api-staging

      - name: Health check
        run: |
          sleep 10
          curl -f --retry 3 --retry-delay 5 https://stg-api.nasibakarkiwari.com/health
```

**Step 2: Commit**

```bash
git add .github/workflows/api-ci.yml
git commit -m "ci: add API CI workflow for staging deploy"
```

---

### Task 3: Create Admin CI workflow (staging)

**Files:**
- Create: `.github/workflows/admin-ci.yml`

**Step 1: Create the workflow file**

```yaml
name: Admin CI

on:
  push:
    branches: [main]
    paths:
      - 'admin/**'
      - 'docker/Dockerfile.admin'
  workflow_call:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: iqbalmuhyiddin/kiwari-admin

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Log in to ghcr.io
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.admin
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging

  deploy-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Deploy to staging
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            echo ${{ secrets.GHCR_TOKEN }} | docker login ghcr.io -u iqbalmuhyiddin --password-stdin
            cd ~/docker/pos-staging
            docker compose pull pos-admin-staging
            docker compose up -d pos-admin-staging

      - name: Health check
        run: |
          sleep 10
          curl -f --retry 3 --retry-delay 5 https://stg-admin.nasibakarkiwari.com/
```

**Step 2: Commit**

```bash
git add .github/workflows/admin-ci.yml
git commit -m "ci: add Admin CI workflow for staging deploy"
```

---

### Task 4: Create production promotion workflow

**Files:**
- Create: `.github/workflows/promote.yml`

**Step 1: Create the workflow file**

```yaml
name: Promote to Production

on:
  push:
    tags:
      - 'v*'

env:
  REGISTRY: ghcr.io

jobs:
  promote-images:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Log in to ghcr.io
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Promote API image
        run: |
          docker pull ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-api:staging
          docker tag ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-api:staging ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-api:${{ github.ref_name }}
          docker tag ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-api:staging ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-api:latest
          docker push ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-api:${{ github.ref_name }}
          docker push ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-api:latest

      - name: Promote Admin image
        run: |
          docker pull ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-admin:staging
          docker tag ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-admin:staging ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-admin:${{ github.ref_name }}
          docker tag ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-admin:staging ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-admin:latest
          docker push ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-admin:${{ github.ref_name }}
          docker push ${{ env.REGISTRY }}/iqbalmuhyiddin/kiwari-admin:latest

  deploy-production:
    needs: promote-images
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Deploy to production
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            echo ${{ secrets.GHCR_TOKEN }} | docker login ghcr.io -u iqbalmuhyiddin --password-stdin
            cd ~/docker/pos-production
            docker compose pull
            docker compose up -d

      - name: Health check
        run: |
          sleep 10
          curl -f --retry 3 --retry-delay 5 https://api.nasibakarkiwari.com/health
          curl -f --retry 3 --retry-delay 5 https://admin.nasibakarkiwari.com/
```

**Step 2: Commit**

```bash
git add .github/workflows/promote.yml
git commit -m "ci: add production promotion workflow"
```

---

### Task 5: Create VPS Docker Compose files

These files live in the repo under `deploy/` for version control, and get copied to the VPS during initial setup.

**Files:**
- Create: `deploy/postgres/docker-compose.yml`
- Create: `deploy/postgres/.env.example`
- Create: `deploy/postgres/init/init-databases.sh`
- Create: `deploy/staging/docker-compose.yml`
- Create: `deploy/staging/.env.example`
- Create: `deploy/production/docker-compose.yml`
- Create: `deploy/production/.env.example`

**Step 1: Create shared PostgreSQL compose**

`deploy/postgres/docker-compose.yml`:

```yaml
services:
  postgres:
    image: postgres:16-alpine
    container_name: postgres
    restart: unless-stopped
    env_file: .env
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./init:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - proxy

volumes:
  pgdata:

networks:
  proxy:
    external: true
```

`deploy/postgres/.env.example`:

```bash
POSTGRES_USER=postgres
POSTGRES_PASSWORD=change-me

# Used by init script
POS_STG_PASSWORD=change-me-staging
POS_PROD_PASSWORD=change-me-production
```

`deploy/postgres/init/init-databases.sh`:

```bash
#!/bin/bash
set -e

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" <<-EOSQL
    CREATE USER pos_stg WITH PASSWORD '${POS_STG_PASSWORD}';
    CREATE DATABASE pos_staging OWNER pos_stg;
    GRANT ALL PRIVILEGES ON DATABASE pos_staging TO pos_stg;

    CREATE USER pos_prod WITH PASSWORD '${POS_PROD_PASSWORD}';
    CREATE DATABASE pos_production OWNER pos_prod;
    GRANT ALL PRIVILEGES ON DATABASE pos_production TO pos_prod;
EOSQL
```

**Step 2: Create staging compose**

`deploy/staging/docker-compose.yml`:

```yaml
services:
  pos-api-staging:
    image: ghcr.io/iqbalmuhyiddin/kiwari-api:staging
    container_name: pos-api-staging
    restart: unless-stopped
    env_file: .env
    networks:
      - proxy

  pos-admin-staging:
    image: ghcr.io/iqbalmuhyiddin/kiwari-admin:staging
    container_name: pos-admin-staging
    restart: unless-stopped
    env_file: .env
    networks:
      - proxy

networks:
  proxy:
    external: true
```

`deploy/staging/.env.example`:

```bash
DATABASE_URL=postgres://pos_stg:change-me@postgres:5432/pos_staging?sslmode=disable
PORT=8081
JWT_SECRET=change-me-staging-jwt-secret
API_URL=http://pos-api-staging:8081
```

**Step 3: Create production compose**

`deploy/production/docker-compose.yml`:

```yaml
services:
  pos-api:
    image: ghcr.io/iqbalmuhyiddin/kiwari-api:latest
    container_name: pos-api
    restart: unless-stopped
    env_file: .env
    networks:
      - proxy

  pos-admin:
    image: ghcr.io/iqbalmuhyiddin/kiwari-admin:latest
    container_name: pos-admin
    restart: unless-stopped
    env_file: .env
    networks:
      - proxy

networks:
  proxy:
    external: true
```

`deploy/production/.env.example`:

```bash
DATABASE_URL=postgres://pos_prod:change-me@postgres:5432/pos_production?sslmode=disable
PORT=8081
JWT_SECRET=change-me-production-jwt-secret
API_URL=http://pos-api:8081
```

**Step 4: Commit**

```bash
git add deploy/
git commit -m "ci: add VPS deploy compose files for staging and production"
```

---

### Task 6: Add deploy/ to .gitignore exceptions and update .env.example

We need to make sure `deploy/*/.env` files are ignored (they contain secrets on VPS) but `.env.example` files are tracked.

**Files:**
- Modify: `.gitignore`

**Step 1: Add deploy ignore rules**

Append to `.gitignore`:

```
# ── Deploy ───────────────────────
deploy/*/.env
!deploy/*/.env.example
deploy/postgres/init/*.env
```

**Step 2: Commit**

```bash
git add .gitignore
git commit -m "chore: add deploy env files to gitignore"
```

---

### Task 7: VPS setup (manual — not automated)

This task is done manually on the VPS, NOT in CI. Checklist for reference:

**Prerequisites:**
- [ ] Generate deploy SSH key: `ssh-keygen -t ed25519 -f ~/.ssh/pos-deploy -C "github-actions-deploy"`
- [ ] Add public key to VPS `~/.ssh/authorized_keys`
- [ ] Add private key to GitHub repo secret `VPS_SSH_KEY`
- [ ] Create GitHub PAT with `read:packages`, add to repo secret `GHCR_TOKEN`
- [ ] Add repo secrets: `VPS_HOST` = `43.173.30.193`, `VPS_USER` = `iqbal`
- [ ] Create GitHub environments: `staging`, `production`

**On VPS:**
- [ ] `scp -r deploy/postgres/ iqbal@43.173.30.193:~/docker/postgres/`
- [ ] `scp -r deploy/staging/ iqbal@43.173.30.193:~/docker/pos-staging/`
- [ ] `scp -r deploy/production/ iqbal@43.173.30.193:~/docker/pos-production/`
- [ ] SSH in: create `.env` from `.env.example` in each directory with real passwords
- [ ] Start PostgreSQL: `cd ~/docker/postgres && docker compose up -d`
- [ ] Run initial migration against staging DB
- [ ] Run initial migration against production DB
- [ ] Docker login to ghcr.io on VPS
- [ ] Add 4 Cloudflare DNS A records (stg-api, stg-admin, api, admin → 43.173.30.193)
- [ ] Add 4 NPM proxy hosts with SSL

**NPM Proxy Host Config:**

| Domain | Container | Port | WebSocket |
|--------|-----------|------|-----------|
| stg-api.nasibakarkiwari.com | pos-api-staging | 8081 | Yes |
| stg-admin.nasibakarkiwari.com | pos-admin-staging | 3000 | No |
| api.nasibakarkiwari.com | pos-api | 8081 | Yes |
| admin.nasibakarkiwari.com | pos-admin | 3000 | No |
